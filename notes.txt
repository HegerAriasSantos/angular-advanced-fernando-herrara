Observables:

- new Observable( observer => { ... } ) - receives an Observer and returns a Subscription, with the the Observer's next, error, and complete methods as arguments.

observer.next(value) - notifies the Observer that a new value is available.
observer.error(error) - notifies the Observer that an error has occurred.
observer.complete() - notifies the Observer that the Observable has completed.


- obs$.subscribe( 
  value => { ... } - receives a function that is called when the Observable emits a value, and returns a Subscription.
  error => { ... } - receives a function that is called when the Observable emits an error, and returns a Subscription.
  () => { ... } - receives a function that is called when the Observable completes, and returns a Subscription.
  )


Pipe: It is used to chain multiple operators into a single function. It is a function that takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.

Pipes:

PD: The operators are executed in the order they are specified in the pipe() function.

- retry(3) - retries a failed Observable up to a specified number of times before failing. If the count is not specified, it retries indefinitely.
- take(3) - takes the first n values from an Observable, then completes, where n is the argument passed to take. If n is not specified, it returns all values in the source Observable.
- map - transforms the items emitted by an Observable by applying a function to each item. It is a function that takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.
- filter - filters the items emitted by an Observable by only emitting those that satisfy a specified predicate, that return true or false when passed to the predicate function.